{
  "lote": 0,
  "status": "pending",
  "file_path": "src/lib/useRitualLogs.ts",
  "created_at": "2026-02-27T05:36:08.171Z",
  "file_content": "/**\n * useRitualLogs â€” Hook para registro formal de rituais\n * v1.1: Constancia, badges automaticas, metricas\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase, TIMEOUTS } from './supabase';\nimport { cleanTextInput, MAX_LENGTHS } from './security';\n\nexport type RitualType = 'daily' | 'weekly' | 'monthly' | 'territorial' | 'entry';\n\nexport interface RitualLog {\n  id: string;\n  user_id: string;\n  ritual_type: RitualType;\n  community_id: string | null;\n  response_text: string | null;\n  completed_at: string;\n}\n\nexport interface RitualStats {\n  totalCompleted: number;\n  consecutiveWeeks: number;\n  lastCompleted: string | null;\n  byType: Record<RitualType, number>;\n  hasEntryRitual: boolean;\n}\n\nexport function useRitualLogs(userId?: string) {\n  const [logs, setLogs] = useState<RitualLog[]>([]);\n  const [stats, setStats] = useState<RitualStats>({\n    totalCompleted: 0,\n    consecutiveWeeks: 0,\n    lastCompleted: null,\n    byType: { daily: 0, weekly: 0, monthly: 0, territorial: 0, entry: 0 },\n    hasEntryRitual: false,\n  });\n  const [isLoading, setIsLoading] = useState(false);\n\n  const loadLogs = useCallback(async () => {\n    if (!userId) return;\n    setIsLoading(true);\n\n    try {\n      const { data, error } = await supabase\n        .from('ritual_logs')\n        .select('*')\n        .eq('user_id', userId)\n        .order('completed_at', { ascending: false })\n        .limit(100)\n        .abortSignal(AbortSignal.timeout(TIMEOUTS.QUERY));\n\n      if (error) throw error;\n\n      const ritualLogs = (data || []) as RitualLog[];\n      setLogs(ritualLogs);\n\n      // Calcular stats\n      const byType: Record<RitualType, number> = { daily: 0, weekly: 0, monthly: 0, territorial: 0, entry: 0 };\n      ritualLogs.forEach(log => {\n        if (byType[log.ritual_type] !== undefined) {\n          byType[log.ritual_type]++;\n        }\n      });\n\n      // Calcular semanas consecutivas (baseado em rituais diarios/semanais)\n      const weeklyLogs = ritualLogs\n        .filter(l => l.ritual_type === 'daily' || l.ritual_type === 'weekly')\n        .map(l => new Date(l.completed_at));\n\n      let consecutiveWeeks = 0;\n      if (weeklyLogs.length > 0) {\n        const now = new Date();\n        const msPerWeek = 7 * 24 * 60 * 60 * 1000;\n        let currentWeekStart = new Date(now);\n        currentWeekStart.setDate(currentWeekStart.getDate() - currentWeekStart.getDay());\n        currentWeekStart.setHours(0, 0, 0, 0);\n\n        for (let i = 0; i < 52; i++) { // max 1 ano\n          const weekStart = new Date(currentWeekStart.getTime() - (i * msPerWeek));\n          const weekEnd = new Date(weekStart.getTime() + msPerWeek);\n          const hasActivity = weeklyLogs.some(d => d >= weekStart && d < weekEnd);\n          if (hasActivity) {\n            consecutiveWeeks++;\n          } else {\n            break;\n          }\n        }\n      }\n\n      setStats({\n        totalCompleted: ritualLogs.length,\n        consecutiveWeeks,\n        lastCompleted: ritualLogs[0]?.completed_at || null,\n        byType,\n        hasEntryRitual: byType.entry > 0,\n      });\n    } catch (err) {\n      console.error('[useRitualLogs] Erro ao carregar:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId]);\n\n  useEffect(() => {\n    loadLogs();\n  }, [loadLogs]);\n\n  /** Registrar ritual completado */\n  const completeRitual = useCallback(async (\n    ritualType: RitualType,\n    responseText?: string,\n    communityId?: string\n  ): Promise<{ success: boolean; error?: string }> => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return { success: false, error: 'Voce precisa estar logado' };\n\n      // Para ritual de entrada, verificar se ja fez\n      if (ritualType === 'entry') {\n        const { data: existing } = await supabase\n          .from('ritual_logs')\n          .select('id')\n          .eq('user_id', user.id)\n          .eq('ritual_type', 'entry')\n          .limit(1);\n\n        if (existing && existing.length > 0) {\n          return { success: false, error: 'Ritual de entrada ja realizado' };\n        }\n      }\n\n      // Para rituais diarios, verificar se ja fez hoje\n      if (ritualType === 'daily') {\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n        const { data: todayLogs } = await supabase\n          .from('ritual_logs')\n          .select('id')\n          .eq('user_id', user.id)\n          .eq('ritual_type', 'daily')\n          .gte('completed_at', today.toISOString())\n          .limit(1);\n\n        if (todayLogs && todayLogs.length > 0) {\n          return { success: false, error: 'Voce ja completou o ritual diario de hoje' };\n        }\n      }\n\n      const cleaned = responseText ? cleanTextInput(responseText, MAX_LENGTHS.DEEP_STATEMENT) : null;\n\n      const { error: insertError } = await supabase\n        .from('ritual_logs')\n        .insert({\n          user_id: user.id,\n          ritual_type: ritualType,\n          response_text: cleaned,\n          community_id: communityId || null,\n        });\n\n      if (insertError) throw insertError;\n\n      await loadLogs();\n      return { success: true };\n    } catch (err: any) {\n      console.error('[useRitualLogs] Erro ao registrar:', err);\n      return { success: false, error: err.message || 'Erro ao registrar ritual' };\n    }\n  }, [loadLogs]);\n\n  /** Verificar se tem direito ao badge de constancia (4+ semanas) */\n  const hasConsistencyBadge = stats.consecutiveWeeks >= 4;\n\n  return {\n    logs,\n    stats,\n    isLoading,\n    completeRitual,\n    refreshLogs: loadLogs,\n    hasConsistencyBadge,\n  };\n}\n"
}