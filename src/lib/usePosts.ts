{
  "lote": 0,
  "status": "pending",
  "file_path": "src/lib/usePosts.ts",
  "created_at": "2026-02-27T05:36:07.053Z",
  "file_content": "import { useState, useEffect, useRef, useCallback } from 'react';\nimport { supabase, TIMEOUTS } from './supabase';\nimport type { Post, User } from './supabase';\n\nexport interface PostWithAuthor extends Post {\n  author_data: User;\n}\n\ninterface UsePostsOptions {\n  isPublicFeed?: boolean;\n  communityId?: string | null;\n  authorId?: string | null;\n}\n\nconst PAGE_SIZE = 20;\nconst QUERY_TIMEOUT = TIMEOUTS.QUERY; // 30s — fonte única de verdade em supabase.ts\n\nfunction withTimeout<T>(promise: PromiseLike<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout: servidor não respondeu')), ms)\n    ),\n  ]) as Promise<T>;\n}\n\nexport function usePosts(isPublicFeedOrOptions: boolean | UsePostsOptions = false) {\n  const [pinnedPosts, setPinnedPosts] = useState<PostWithAuthor[]>([]);\n  const [regularPosts, setRegularPosts] = useState<PostWithAuthor[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isLoadingMore, setIsLoadingMore] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [hasMore, setHasMore] = useState(true);\n\n  const options: UsePostsOptions = typeof isPublicFeedOrOptions === 'boolean'\n    ? { isPublicFeed: isPublicFeedOrOptions }\n    : isPublicFeedOrOptions;\n\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n\n  const filterKey = `${options.isPublicFeed || false}-${options.communityId || 'none'}-${options.authorId || 'none'}`;\n\n  const buildQuery = useCallback((isPinned?: boolean) => {\n    let q = supabase\n      .from('posts')\n      .select(`*, author_data:users!author(id,name,display_name,profile_photo,role,bio)`)\n      .order('created_at', { ascending: false });\n\n    const o = optionsRef.current;\n    if (o.isPublicFeed) q = q.eq('is_public', true);\n    if (o.communityId)  q = q.eq('community', o.communityId);\n    if (o.authorId)     q = q.eq('author', o.authorId);\n    if (isPinned === true)  q = q.eq('is_pinned', true);\n    if (isPinned === false) q = q.eq('is_pinned', false);\n    return q;\n  }, []);\n\n  const enrichWithAuthors = useCallback(async (raw: Post[]): Promise<PostWithAuthor[]> => {\n    if (!raw.length) return [];\n    const ids = [...new Set(raw.map(p => p.author))];\n    const { data: authors } = await withTimeout(\n      supabase.from('users').select('id,name,display_name,profile_photo,role,bio').in('id', ids),\n      QUERY_TIMEOUT\n    );\n    const m: Record<string, any> = {};\n    authors?.forEach(a => { m[a.id] = a; });\n    return raw.map(p => ({\n      ...p,\n      author_data: m[p.author] || { id: p.author, name: 'Membro', profile_photo: null, role: 'member', bio: null },\n    }));\n  }, []);\n\n  const loadPosts = useCallback(async () => {\n    const o = optionsRef.current;\n    if ('authorId' in o && !o.authorId) {\n      setPinnedPosts([]); setRegularPosts([]); setIsLoading(false); return;\n    }\n    try {\n      setIsLoading(true); setError(null); setHasMore(true);\n\n      // Pinned posts\n      const { data: pinData, error: pinErr } = await withTimeout(buildQuery(true), QUERY_TIMEOUT);\n      if (pinErr) {\n        const { data: raw } = await withTimeout(\n          supabase.from('posts').select('*').eq('is_pinned', true).order('created_at', { ascending: false }),\n          QUERY_TIMEOUT\n        );\n        setPinnedPosts(raw ? await enrichWithAuthors(raw) : []);\n      } else {\n        setPinnedPosts((pinData as PostWithAuthor[]) || []);\n      }\n\n      // Regular posts (first page)\n      const { data: regData, error: regErr } = await withTimeout(buildQuery(false).limit(PAGE_SIZE + 1), QUERY_TIMEOUT);\n      if (regErr) {\n        let fq = supabase.from('posts').select('*').eq('is_pinned', false)\n          .order('created_at', { ascending: false }).limit(PAGE_SIZE + 1);\n        if (o.isPublicFeed) fq = fq.eq('is_public', true);\n        if (o.communityId)  fq = fq.eq('community', o.communityId);\n        if (o.authorId)     fq = fq.eq('author', o.authorId);\n        const { data: raw } = await withTimeout(fq, QUERY_TIMEOUT);\n        const enriched = raw ? await enrichWithAuthors(raw) : [];\n        setHasMore(enriched.length > PAGE_SIZE);\n        setRegularPosts(enriched.slice(0, PAGE_SIZE));\n      } else {\n        const d = (regData as PostWithAuthor[]) || [];\n        setHasMore(d.length > PAGE_SIZE);\n        setRegularPosts(d.slice(0, PAGE_SIZE));\n      }\n    } catch (err: any) {\n      console.error('usePosts error:', err);\n      setError(err.message || 'Erro ao carregar posts');\n      setPinnedPosts([]); setRegularPosts([]);\n    } finally { setIsLoading(false); }\n  }, [buildQuery, enrichWithAuthors]);\n\n  const loadMore = useCallback(async () => {\n    if (!hasMore || isLoadingMore) return;\n    const last = regularPosts[regularPosts.length - 1];\n    if (!last) return;\n    try {\n      setIsLoadingMore(true);\n      const { data, error: err } = await withTimeout(\n        buildQuery(false).lt('created_at', last.created_at).limit(PAGE_SIZE + 1),\n        QUERY_TIMEOUT\n      );\n      if (err) {\n        const o = optionsRef.current;\n        let fq = supabase.from('posts').select('*').eq('is_pinned', false)\n          .lt('created_at', last.created_at)\n          .order('created_at', { ascending: false }).limit(PAGE_SIZE + 1);\n        if (o.isPublicFeed) fq = fq.eq('is_public', true);\n        if (o.communityId)  fq = fq.eq('community', o.communityId);\n        if (o.authorId)     fq = fq.eq('author', o.authorId);\n        const { data: raw } = await withTimeout(fq, QUERY_TIMEOUT);\n        const enriched = raw ? await enrichWithAuthors(raw) : [];\n        setHasMore(enriched.length > PAGE_SIZE);\n        setRegularPosts(prev => [...prev, ...enriched.slice(0, PAGE_SIZE)]);\n      } else {\n        const d = (data as PostWithAuthor[]) || [];\n        setHasMore(d.length > PAGE_SIZE);\n        setRegularPosts(prev => [...prev, ...d.slice(0, PAGE_SIZE)]);\n      }\n    } finally { setIsLoadingMore(false); }\n  }, [hasMore, isLoadingMore, regularPosts, buildQuery, enrichWithAuthors]);\n\n  const deletePost = useCallback(async (postId: string) => {\n    try {\n      const { error } = await withTimeout(\n        supabase.from('posts').delete().eq('id', postId),\n        QUERY_TIMEOUT\n      );\n      if (error) throw error;\n      setPinnedPosts(prev => prev.filter(p => p.id !== postId));\n      setRegularPosts(prev => prev.filter(p => p.id !== postId));\n      return { success: true };\n    } catch (err: any) { return { success: false, error: err.message }; }\n  }, []);\n\n  useEffect(() => { loadPosts(); }, [filterKey]);\n\n  return {\n    posts: [...pinnedPosts, ...regularPosts],\n    isLoading,\n    isLoadingMore,\n    error,\n    hasMore,\n    loadMore,\n    refreshPosts: loadPosts,\n    deletePost,\n  };\n}"
}