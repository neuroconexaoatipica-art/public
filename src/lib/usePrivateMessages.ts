{
  "lote": 0,
  "status": "pending",
  "file_path": "src/lib/usePrivateMessages.ts",
  "created_at": "2026-02-27T05:36:07.129Z",
  "file_content": "import { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from './supabase';\n\nexport interface PrivateMessage {\n  id: string;\n  sender_id: string;\n  receiver_id: string;\n  content: string;\n  is_read: boolean;\n  created_at: string;\n  sender_data?: { id: string; name: string; display_name?: string; profile_photo: string | null };\n}\n\nexport interface Conversation {\n  other_user_id: string;\n  other_user_name: string;\n  other_user_photo: string | null;\n  last_message: string;\n  last_message_at: string;\n  unread_count: number;\n}\n\nexport function usePrivateMessages(otherUserId?: string) {\n  const [messages, setMessages] = useState<PrivateMessage[]>([]);\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const channelRef = useRef<ReturnType<typeof supabase.channel> | null>(null);\n\n  // Carregar mensagens de uma conversa especifica\n  const loadMessages = useCallback(async () => {\n    if (!otherUserId) return;\n    try {\n      setIsLoading(true);\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return;\n\n      const { data, error } = await supabase\n        .from('private_messages')\n        .select('*')\n        .or(`and(sender_id.eq.${user.id},receiver_id.eq.${otherUserId}),and(sender_id.eq.${otherUserId},receiver_id.eq.${user.id})`)\n        .order('created_at', { ascending: true })\n        .limit(200);\n\n      if (error) throw error;\n\n      // Marcar como lidas\n      if (data && data.length > 0) {\n        const unreadIds = data.filter(m => m.receiver_id === user.id && !m.is_read).map(m => m.id);\n        if (unreadIds.length > 0) {\n          await supabase.from('private_messages').update({ is_read: true }).in('id', unreadIds);\n        }\n      }\n\n      // Enriquecer com dados do sender\n      const senderIds = [...new Set((data || []).map(m => m.sender_id))];\n      let sendersMap: Record<string, any> = {};\n      if (senderIds.length > 0) {\n        const { data: senders } = await supabase\n          .from('users').select('id, name, display_name, profile_photo').in('id', senderIds);\n        (senders || []).forEach(s => { sendersMap[s.id] = s; });\n      }\n\n      setMessages((data || []).map(m => ({\n        ...m,\n        sender_data: sendersMap[m.sender_id] || { id: m.sender_id, name: 'Membro', display_name: null, profile_photo: null }\n      })));\n    } catch (err) {\n      console.error('[usePrivateMessages] Erro:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [otherUserId]);\n\n  // Carregar lista de conversas\n  const loadConversations = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return;\n\n      const { data, error } = await supabase\n        .from('private_messages')\n        .select('*')\n        .or(`sender_id.eq.${user.id},receiver_id.eq.${user.id}`)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n\n      // Agrupar por conversa\n      const convMap: Record<string, { messages: any[]; unread: number }> = {};\n      (data || []).forEach(m => {\n        const otherId = m.sender_id === user.id ? m.receiver_id : m.sender_id;\n        if (!convMap[otherId]) convMap[otherId] = { messages: [], unread: 0 };\n        convMap[otherId].messages.push(m);\n        if (m.receiver_id === user.id && !m.is_read) convMap[otherId].unread++;\n      });\n\n      // Buscar dados dos outros usuarios\n      const otherIds = Object.keys(convMap);\n      let usersMap: Record<string, any> = {};\n      if (otherIds.length > 0) {\n        const { data: users } = await supabase\n          .from('users').select('id, name, display_name, profile_photo').in('id', otherIds);\n        (users || []).forEach(u => { usersMap[u.id] = u; });\n      }\n\n      const convList: Conversation[] = otherIds.map(otherId => {\n        const conv = convMap[otherId];\n        const lastMsg = conv.messages[0];\n        const otherUser = usersMap[otherId] || { name: 'Membro', display_name: null, profile_photo: null };\n        return {\n          other_user_id: otherId,\n          other_user_name: otherUser.display_name || otherUser.name,\n          other_user_photo: otherUser.profile_photo,\n          last_message: lastMsg.content,\n          last_message_at: lastMsg.created_at,\n          unread_count: conv.unread,\n        };\n      }).sort((a, b) => new Date(b.last_message_at).getTime() - new Date(a.last_message_at).getTime());\n\n      setConversations(convList);\n    } catch (err) {\n      console.error('[usePrivateMessages] Erro conversas:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // Realtime para mensagens novas\n  useEffect(() => {\n    if (otherUserId) {\n      loadMessages();\n    } else {\n      loadConversations();\n    }\n\n    const setupRealtime = async () => {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return;\n\n      const channel = supabase\n        .channel('dm-realtime')\n        .on('postgres_changes', {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'private_messages',\n          filter: `receiver_id=eq.${user.id}`,\n        }, (payload) => {\n          const newMsg = payload.new as PrivateMessage;\n          if (otherUserId && newMsg.sender_id === otherUserId) {\n            setMessages(prev => [...prev, newMsg]);\n            // Marcar como lida\n            supabase.from('private_messages').update({ is_read: true }).eq('id', newMsg.id);\n          } else {\n            loadConversations();\n          }\n        })\n        .subscribe();\n\n      channelRef.current = channel;\n      return () => { supabase.removeChannel(channel); };\n    };\n\n    const cleanup = setupRealtime();\n    return () => { cleanup.then(fn => fn?.()); };\n  }, [otherUserId, loadMessages, loadConversations]);\n\n  const sendMessage = useCallback(async (receiverId: string, content: string) => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return { success: false, error: 'Nao autenticado' };\n\n      const { error } = await supabase.from('private_messages').insert({\n        sender_id: user.id,\n        receiver_id: receiverId,\n        content: content.trim(),\n      });\n\n      if (error) throw error;\n      return { success: true };\n    } catch (err: any) {\n      return { success: false, error: err.message };\n    }\n  }, []);\n\n  return { messages, conversations, isLoading, sendMessage, refresh: otherUserId ? loadMessages : loadConversations };\n}"
}