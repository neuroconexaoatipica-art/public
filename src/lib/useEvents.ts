{
  "lote": 0,
  "status": "pending",
  "file_path": "src/lib/useEvents.ts",
  "created_at": "2026-02-27T05:36:05.196Z",
  "file_content": "import { useState, useEffect, useCallback } from 'react';\nimport { supabase } from './supabase';\nimport type { Event, EventParticipant, EventType, RitualType, EventStatus, LocationType } from './supabase';\n\n// ═══════════════════════════════════════════════════════════════\n// HOOK useEvents — Fase 2 V8\n// CRUD de eventos + participação + rituais\n// ═══════════════════════════════════════════════════════════════\n\nexport interface EventWithMeta extends Event {\n  host_name: string;\n  host_photo: string | null;\n  community_name: string | null;\n  participant_count: number;\n  is_participating: boolean;\n  my_status: 'confirmed' | 'interested' | 'cancelled' | null;\n}\n\nexport interface CreateEventInput {\n  community_id?: string | null;\n  title: string;\n  description: string;\n  event_type: EventType;\n  ritual_type?: RitualType | null;\n  starts_at: string;\n  ends_at?: string | null;\n  max_participants?: number | null;\n  status?: EventStatus;\n  location_type: LocationType;\n  location_url?: string;\n  location_address?: string;\n  cover_image_url?: string | null;\n}\n\n// ─── Labels & Config ─────────────────────────────────────────\n\nexport const EVENT_TYPE_LABELS: Record<EventType, string> = {\n  live: 'Live',\n  workshop: 'Workshop',\n  ritual: 'Ritual',\n  encontro: 'Encontro',\n  debate: 'Debate',\n  oficina: 'Oficina',\n  outro: 'Outro',\n};\n\nexport const RITUAL_TYPE_LABELS: Record<RitualType, string> = {\n  roda_de_escuta: 'Roda de Escuta',\n  checkin_coletivo: 'Check-in Coletivo',\n  sessao_de_foco: 'Sessao de Foco',\n  desabafo_estruturado: 'Desabafo Estruturado',\n  ritual_de_acolhimento: 'Ritual de Acolhimento',\n  debate_guiado: 'Debate Guiado',\n  reflexao_silenciosa: 'Reflexao Silenciosa',\n};\n\nexport const RITUAL_TYPE_DESCRIPTIONS: Record<RitualType, string> = {\n  roda_de_escuta: 'Cada pessoa fala, as outras escutam. Sem conselho, sem interrupcao. Escuta como ato de presenca.',\n  checkin_coletivo: 'Como voce esta agora? Uma palavra, uma frase, um silencio. Todo mundo responde, ninguem julga.',\n  sessao_de_foco: 'Body doubling coletivo. Cada um no seu, mas juntos. Presenca compartilhada como ancora.',\n  desabafo_estruturado: 'Falar o que precisa sair. Com tempo, com contorno, sem plateia. Cru, mas seguro.',\n  ritual_de_acolhimento: 'Para quem acabou de chegar. Apresentacao sem performance, integracao sem pressao.',\n  debate_guiado: 'Um tema, regras claras, divergencia permitida. Pensar junto sem precisar concordar.',\n  reflexao_silenciosa: 'Tema lancado, silencio coletivo, escrita individual. Pensar antes de falar.',\n};\n\nexport const EVENT_STATUS_LABELS: Record<EventStatus, string> = {\n  draft: 'Rascunho',\n  published: 'Publicado',\n  live: 'Ao Vivo',\n  completed: 'Concluido',\n  cancelled: 'Cancelado',\n};\n\nexport const LOCATION_TYPE_LABELS: Record<LocationType, string> = {\n  online: 'Online',\n  presencial: 'Presencial',\n  hibrido: 'Hibrido',\n};\n\n// ─── Hook Principal ──────────────────────────────────────────\n\ninterface UseEventsOptions {\n  communityId?: string;\n  eventType?: EventType;\n  status?: EventStatus;\n  upcoming?: boolean; // só eventos futuros\n}\n\nexport function useEvents(options: UseEventsOptions = {}) {\n  const [events, setEvents] = useState<EventWithMeta[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const loadEvents = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const { data: { user: authUser } } = await supabase.auth.getUser();\n      const currentUserId = authUser?.id;\n\n      // Query base\n      let query = supabase\n        .from('events')\n        .select('*')\n        .order('starts_at', { ascending: true });\n\n      // Filtros\n      if (options.communityId) {\n        query = query.eq('community_id', options.communityId);\n      }\n      if (options.eventType) {\n        query = query.eq('event_type', options.eventType);\n      }\n      if (options.status) {\n        query = query.eq('status', options.status);\n      }\n      if (options.upcoming) {\n        query = query.gte('starts_at', new Date().toISOString());\n        query = query.in('status', ['published', 'live']);\n      }\n\n      const { data: eventsData, error: eventsError } = await query;\n      if (eventsError) throw eventsError;\n      if (!eventsData || eventsData.length === 0) {\n        setEvents([]);\n        return;\n      }\n\n      // Buscar hosts (users)\n      const hostIds = [...new Set(eventsData.map(e => e.host_id).filter(Boolean))];\n      const communityIds = [...new Set(eventsData.map(e => e.community_id).filter(Boolean))];\n\n      const [hostsResult, communitiesResult, participantsResult] = await Promise.all([\n        hostIds.length > 0\n          ? supabase.from('users').select('id, name, profile_photo').in('id', hostIds)\n          : { data: [] },\n        communityIds.length > 0\n          ? supabase.from('communities').select('id, name').in('id', communityIds)\n          : { data: [] },\n        supabase.from('event_participants')\n          .select('event_id, user_id, status')\n          .in('event_id', eventsData.map(e => e.id))\n          .neq('status', 'cancelled'),\n      ]);\n\n      const hostsMap: Record<string, { name: string; photo: string | null }> = {};\n      (hostsResult.data || []).forEach((h: any) => {\n        hostsMap[h.id] = { name: h.name, photo: h.profile_photo };\n      });\n\n      const communitiesMap: Record<string, string> = {};\n      (communitiesResult.data || []).forEach((c: any) => {\n        communitiesMap[c.id] = c.name;\n      });\n\n      // Contagem de participantes por evento\n      const participantCountMap: Record<string, number> = {};\n      const myParticipation: Record<string, { is: boolean; status: 'confirmed' | 'interested' | 'cancelled' }> = {};\n      (participantsResult.data || []).forEach((p: any) => {\n        participantCountMap[p.event_id] = (participantCountMap[p.event_id] || 0) + 1;\n        if (p.user_id === currentUserId) {\n          myParticipation[p.event_id] = { is: true, status: p.status };\n        }\n      });\n\n      const enriched: EventWithMeta[] = eventsData.map((e: any) => ({\n        ...e,\n        host_name: hostsMap[e.host_id]?.name || 'Desconhecido',\n        host_photo: hostsMap[e.host_id]?.photo || null,\n        community_name: e.community_id ? (communitiesMap[e.community_id] || null) : null,\n        participant_count: participantCountMap[e.id] || 0,\n        is_participating: myParticipation[e.id]?.is || false,\n        my_status: myParticipation[e.id]?.status || null,\n      }));\n\n      setEvents(enriched);\n    } catch (err: unknown) {\n      console.error('[useEvents] Erro:', err);\n      setError(err instanceof Error ? err.message : 'Erro ao carregar eventos');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [options.communityId, options.eventType, options.status, options.upcoming]);\n\n  useEffect(() => {\n    loadEvents();\n  }, [loadEvents]);\n\n  // ─── Criar evento ──────────────────────────────────────────\n\n  const createEvent = useCallback(async (input: CreateEventInput): Promise<Event | null> => {\n    try {\n      const { data: { user: authUser } } = await supabase.auth.getUser();\n      if (!authUser) throw new Error('Nao autenticado');\n\n      const { data, error } = await supabase\n        .from('events')\n        .insert({\n          ...input,\n          host_id: authUser.id,\n          ritual_type: input.event_type === 'ritual' ? input.ritual_type : null,\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n      await loadEvents();\n      return data;\n    } catch (err: unknown) {\n      console.error('[useEvents] Erro ao criar:', err);\n      throw err;\n    }\n  }, [loadEvents]);\n\n  // ─── Atualizar evento ──────────────────────────────────────\n\n  const updateEvent = useCallback(async (eventId: string, updates: Partial<CreateEventInput>): Promise<void> => {\n    try {\n      const { error } = await supabase\n        .from('events')\n        .update(updates)\n        .eq('id', eventId);\n\n      if (error) throw error;\n      await loadEvents();\n    } catch (err: unknown) {\n      console.error('[useEvents] Erro ao atualizar:', err);\n      throw err;\n    }\n  }, [loadEvents]);\n\n  // ─── Deletar evento ────────────────────────────────────────\n\n  const deleteEvent = useCallback(async (eventId: string): Promise<void> => {\n    try {\n      const { error } = await supabase\n        .from('events')\n        .delete()\n        .eq('id', eventId);\n\n      if (error) throw error;\n      await loadEvents();\n    } catch (err: unknown) {\n      console.error('[useEvents] Erro ao deletar:', err);\n      throw err;\n    }\n  }, [loadEvents]);\n\n  // ─── Participar / Sair ─────────────────────────────────────\n\n  const joinEvent = useCallback(async (eventId: string, status: 'confirmed' | 'interested' = 'confirmed'): Promise<void> => {\n    try {\n      const { data: { user: authUser } } = await supabase.auth.getUser();\n      if (!authUser) throw new Error('Nao autenticado');\n\n      // Upsert: se já existe, atualiza o status\n      const { error } = await supabase\n        .from('event_participants')\n        .upsert(\n          { event_id: eventId, user_id: authUser.id, status },\n          { onConflict: 'event_id,user_id' }\n        );\n\n      if (error) throw error;\n      await loadEvents();\n    } catch (err: unknown) {\n      console.error('[useEvents] Erro ao participar:', err);\n      throw err;\n    }\n  }, [loadEvents]);\n\n  const leaveEvent = useCallback(async (eventId: string): Promise<void> => {\n    try {\n      const { data: { user: authUser } } = await supabase.auth.getUser();\n      if (!authUser) throw new Error('Nao autenticado');\n\n      const { error } = await supabase\n        .from('event_participants')\n        .delete()\n        .eq('event_id', eventId)\n        .eq('user_id', authUser.id);\n\n      if (error) throw error;\n      await loadEvents();\n    } catch (err: unknown) {\n      console.error('[useEvents] Erro ao sair:', err);\n      throw err;\n    }\n  }, [loadEvents]);\n\n  return {\n    events,\n    isLoading,\n    error,\n    refreshEvents: loadEvents,\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    joinEvent,\n    leaveEvent,\n  };\n}\n\n// ─── Hook para detalhe de evento único ───────────────────────\n\nexport function useEventDetail(eventId: string | null) {\n  const [event, setEvent] = useState<EventWithMeta | null>(null);\n  const [participants, setParticipants] = useState<Array<{ user_id: string; name: string; photo: string | null; status: string }>>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  const load = useCallback(async () => {\n    if (!eventId) { setIsLoading(false); return; }\n\n    try {\n      setIsLoading(true);\n      const { data: { user: authUser } } = await supabase.auth.getUser();\n\n      const { data: eventData, error } = await supabase\n        .from('events')\n        .select('*')\n        .eq('id', eventId)\n        .single();\n\n      if (error) throw error;\n\n      // Host info\n      let hostName = 'Desconhecido';\n      let hostPhoto: string | null = null;\n      if (eventData.host_id) {\n        const { data: hostData } = await supabase\n          .from('users')\n          .select('name, profile_photo')\n          .eq('id', eventData.host_id)\n          .single();\n        if (hostData) { hostName = hostData.name; hostPhoto = hostData.profile_photo; }\n      }\n\n      // Community name\n      let communityName: string | null = null;\n      if (eventData.community_id) {\n        const { data: commData } = await supabase\n          .from('communities')\n          .select('name')\n          .eq('id', eventData.community_id)\n          .single();\n        if (commData) communityName = commData.name;\n      }\n\n      // Participants\n      const { data: parts } = await supabase\n        .from('event_participants')\n        .select('user_id, status')\n        .eq('event_id', eventId)\n        .neq('status', 'cancelled');\n\n      const userIds = (parts || []).map(p => p.user_id);\n      let usersMap: Record<string, { name: string; photo: string | null }> = {};\n      if (userIds.length > 0) {\n        const { data: usersData } = await supabase\n          .from('users')\n          .select('id, name, profile_photo')\n          .in('id', userIds);\n        (usersData || []).forEach((u: any) => { usersMap[u.id] = { name: u.name, photo: u.profile_photo }; });\n      }\n\n      const enrichedParts = (parts || []).map(p => ({\n        user_id: p.user_id,\n        name: usersMap[p.user_id]?.name || 'Desconhecido',\n        photo: usersMap[p.user_id]?.photo || null,\n        status: p.status,\n      }));\n\n      const myPart = parts?.find(p => p.user_id === authUser?.id);\n\n      setEvent({\n        ...eventData,\n        host_name: hostName,\n        host_photo: hostPhoto,\n        community_name: communityName,\n        participant_count: enrichedParts.length,\n        is_participating: !!myPart,\n        my_status: (myPart?.status as any) || null,\n      });\n      setParticipants(enrichedParts);\n    } catch (err) {\n      console.error('[useEventDetail] Erro:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [eventId]);\n\n  useEffect(() => { load(); }, [load]);\n\n  return { event, participants, isLoading, refresh: load };\n}\n"
}