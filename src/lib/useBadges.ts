{
  "lote": 0,
  "status": "pending",
  "file_path": "src/lib/useBadges.ts",
  "created_at": "2026-02-27T05:36:03.058Z",
  "file_content": "/**\n * useBadges — Hook para badges visuais de status\n * v1.2: Badges de pertencimento, reconhecimento + motor de concessao automatica\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase, TIMEOUTS } from './supabase';\n\nexport type BadgeType =\n  | 'nucleo_inicial'\n  | 'trinta_primeiros'\n  | 'vitalicio'\n  | 'founder'\n  | 'coordenador_territorial'\n  | 'constancia_ritual'\n  | 'presenca_territorial'\n  | 'lideranca'\n  | 'presenca';\n\nexport interface UserBadge {\n  id: string;\n  user_id: string;\n  badge_type: BadgeType;\n  earned_at: string;\n  is_active: boolean;\n}\n\n/** Configuracao visual de cada badge */\nexport const BADGE_CONFIG: Record<BadgeType, {\n  label: string;\n  emoji: string;\n  color: string;\n  bgColor: string;\n  description: string;\n}> = {\n  nucleo_inicial: {\n    label: 'Nucleo Inicial',\n    emoji: '\\u2B50', // estrela\n    color: '#FFD700',\n    bgColor: 'rgba(255, 215, 0, 0.15)',\n    description: 'Membro desde o inicio da plataforma',\n  },\n  trinta_primeiros: {\n    label: '30 Primeiros',\n    emoji: '\\uD83C\\uDFC6', // trofeu\n    color: '#FF6B35',\n    bgColor: 'rgba(255, 107, 53, 0.15)',\n    description: 'Entre os 30 primeiros membros',\n  },\n  vitalicio: {\n    label: 'Vitalicio',\n    emoji: '\\u267E\\uFE0F', // infinito\n    color: '#81D8D0',\n    bgColor: 'rgba(129, 216, 208, 0.15)',\n    description: 'Acesso vitalicio gratuito',\n  },\n  founder: {\n    label: 'Founder',\n    emoji: '\\uD83D\\uDC51', // coroa\n    color: '#C8102E',\n    bgColor: 'rgba(200, 16, 46, 0.15)',\n    description: 'Fundador(a) de comunidade',\n  },\n  coordenador_territorial: {\n    label: 'Coordenador',\n    emoji: '\\uD83C\\uDF0D', // globo\n    color: '#FF6B35',\n    bgColor: 'rgba(255, 107, 53, 0.15)',\n    description: 'Coordenador(a) de nucleo territorial',\n  },\n  constancia_ritual: {\n    label: 'Constancia',\n    emoji: '\\uD83D\\uDD25', // fogo\n    color: '#FF4500',\n    bgColor: 'rgba(255, 69, 0, 0.15)',\n    description: '4+ semanas consecutivas de rituais',\n  },\n  presenca_territorial: {\n    label: 'Territorio',\n    emoji: '\\uD83D\\uDCCD', // pin\n    color: '#FF6B35',\n    bgColor: 'rgba(255, 107, 53, 0.15)',\n    description: '3+ encontros presenciais',\n  },\n  lideranca: {\n    label: 'Lideranca',\n    emoji: '\\uD83C\\uDF1F', // estrela brilhante\n    color: '#A855F7',\n    bgColor: 'rgba(168, 85, 247, 0.15)',\n    description: 'Organizou 1+ live ou evento',\n  },\n  presenca: {\n    label: 'Presenca',\n    emoji: '\\uD83D\\uDCAC', // balao\n    color: '#81D8D0',\n    bgColor: 'rgba(129, 216, 208, 0.15)',\n    description: '10+ comentarios relevantes',\n  },\n};\n\nexport function useBadges(userId?: string) {\n  const [badges, setBadges] = useState<UserBadge[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const loadBadges = useCallback(async () => {\n    if (!userId) return;\n    setIsLoading(true);\n\n    try {\n      const { data, error } = await supabase\n        .from('user_badges')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('is_active', true)\n        .order('earned_at', { ascending: true })\n        .abortSignal(AbortSignal.timeout(TIMEOUTS.QUERY));\n\n      if (error) throw error;\n      setBadges((data || []) as UserBadge[]);\n    } catch (err) {\n      console.error('[useBadges] Erro ao carregar:', err);\n      // Silencioso — badges nao sao criticas\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId]);\n\n  useEffect(() => {\n    loadBadges();\n  }, [loadBadges]);\n\n  /** Verificar se usuario tem um badge especifico */\n  const hasBadge = useCallback((type: BadgeType): boolean => {\n    return badges.some(b => b.badge_type === type);\n  }, [badges]);\n\n  /** Obter config visual de um badge */\n  const getBadgeConfig = (type: BadgeType) => BADGE_CONFIG[type];\n\n  return {\n    badges,\n    isLoading,\n    hasBadge,\n    getBadgeConfig,\n    refreshBadges: loadBadges,\n    badgeCount: badges.length,\n  };\n}\n\n/** Hook para carregar badges de multiplos usuarios (para listas) */\nexport function useBadgesForUsers(userIds: string[]) {\n  const [badgeMap, setBadgeMap] = useState<Record<string, UserBadge[]>>({});\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() => {\n    if (userIds.length === 0) return;\n\n    const load = async () => {\n      setIsLoading(true);\n      try {\n        const { data, error } = await supabase\n          .from('user_badges')\n          .select('*')\n          .in('user_id', userIds)\n          .eq('is_active', true)\n          .abortSignal(AbortSignal.timeout(TIMEOUTS.QUERY));\n\n        if (error) throw error;\n\n        const map: Record<string, UserBadge[]> = {};\n        (data || []).forEach((badge: any) => {\n          if (!map[badge.user_id]) map[badge.user_id] = [];\n          map[badge.user_id].push(badge as UserBadge);\n        });\n        setBadgeMap(map);\n      } catch (err) {\n        console.error('[useBadgesForUsers] Erro:', err);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    load();\n  }, [userIds.join(',')]);\n\n  return { badgeMap, isLoading };\n}\n\n// ═══════════════════════════════════════════════════════════\n// MOTOR DE CONCESSÃO AUTOMÁTICA — Gamificação Invisível\n// Verifica condições e concede selos silenciosamente.\n// ═══════════════════════════════════════════════════════════\n\ninterface BadgeEligibility {\n  type: BadgeType;\n  eligible: boolean;\n  reason: string;\n}\n\n/** Conceder badge se ainda nao possui (idempotente) */\nasync function grantBadgeIfNew(userId: string, badgeType: BadgeType): Promise<boolean> {\n  try {\n    // Verificar se ja tem\n    const { data: existing } = await supabase\n      .from('user_badges')\n      .select('id')\n      .eq('user_id', userId)\n      .eq('badge_type', badgeType)\n      .limit(1);\n\n    if (existing && existing.length > 0) return false; // Ja possui\n\n    const { error } = await supabase\n      .from('user_badges')\n      .insert({\n        user_id: userId,\n        badge_type: badgeType,\n        earned_at: new Date().toISOString(),\n        is_active: true,\n      });\n\n    if (error) {\n      // Conflito de unique = ja existe, tudo bem\n      if (error.code === '23505') return false;\n      throw error;\n    }\n\n    console.log(`[useBadges] Selo concedido: ${badgeType} para ${userId}`);\n    return true;\n  } catch (err) {\n    console.error(`[useBadges] Erro ao conceder ${badgeType}:`, err);\n    return false;\n  }\n}\n\n/** Verificar elegibilidade para TODOS os selos de gamificacao */\nasync function checkAllEligibility(userId: string): Promise<BadgeEligibility[]> {\n  const results: BadgeEligibility[] = [];\n\n  try {\n    // ── 1. SELO CONSTÂNCIA: 4+ semanas consecutivas de rituais ──\n    const { data: ritualLogs } = await supabase\n      .from('ritual_logs')\n      .select('completed_at')\n      .eq('user_id', userId)\n      .order('completed_at', { ascending: false });\n\n    if (ritualLogs && ritualLogs.length > 0) {\n      // Agrupar por semana ISO\n      const weekSet = new Set<string>();\n      ritualLogs.forEach((log: any) => {\n        const d = new Date(log.completed_at);\n        const yearWeek = `${d.getFullYear()}-W${String(getISOWeek(d)).padStart(2, '0')}`;\n        weekSet.add(yearWeek);\n      });\n\n      // Contar semanas consecutivas a partir da mais recente\n      const sortedWeeks = Array.from(weekSet).sort().reverse();\n      let consecutive = 1;\n      for (let i = 1; i < sortedWeeks.length; i++) {\n        if (areConsecutiveWeeks(sortedWeeks[i - 1], sortedWeeks[i])) {\n          consecutive++;\n        } else break;\n      }\n\n      results.push({\n        type: 'constancia_ritual',\n        eligible: consecutive >= 4,\n        reason: `${consecutive} semanas consecutivas de rituais`,\n      });\n    } else {\n      results.push({ type: 'constancia_ritual', eligible: false, reason: '0 rituais registrados' });\n    }\n\n    // ── 2. SELO TERRITÓRIO: 3+ encontros presenciais ──\n    const { data: eventAttendance } = await supabase\n      .from('event_attendees')\n      .select('id, event:event_id (event_type)')\n      .eq('user_id', userId)\n      .eq('status', 'confirmed');\n\n    const presencialCount = (eventAttendance || []).filter(\n      (a: any) => a.event?.event_type === 'presencial' || a.event?.event_type === 'hibrido'\n    ).length;\n\n    results.push({\n      type: 'presenca_territorial',\n      eligible: presencialCount >= 3,\n      reason: `${presencialCount} encontros presenciais`,\n    });\n\n    // ── 3. SELO LIDERANÇA: 1+ live ou evento organizado ──\n    const { data: organizedEvents } = await supabase\n      .from('events')\n      .select('id')\n      .eq('host_id', userId)\n      .limit(1);\n\n    const { data: organizedLives } = await supabase\n      .from('lives')\n      .select('id')\n      .eq('host_id', userId)\n      .limit(1);\n\n    const hasOrganized = ((organizedEvents?.length || 0) + (organizedLives?.length || 0)) >= 1;\n\n    results.push({\n      type: 'lideranca',\n      eligible: hasOrganized,\n      reason: hasOrganized ? 'Organizou evento ou live' : 'Nenhum evento ou live organizado',\n    });\n\n    // ── 4. SELO PRESENÇA: 10+ comentários ──\n    const { count: commentCount } = await supabase\n      .from('comments')\n      .select('*', { count: 'exact', head: true })\n      .eq('author', userId);\n\n    results.push({\n      type: 'presenca',\n      eligible: (commentCount || 0) >= 10,\n      reason: `${commentCount || 0} comentarios`,\n    });\n\n  } catch (err) {\n    console.error('[useBadges] Erro ao verificar elegibilidade:', err);\n  }\n\n  return results;\n}\n\n/** Executar verificacao completa e conceder selos automaticamente */\nexport async function runBadgeEngine(userId: string): Promise<{ granted: BadgeType[] }> {\n  const granted: BadgeType[] = [];\n\n  try {\n    const eligibility = await checkAllEligibility(userId);\n\n    for (const check of eligibility) {\n      if (check.eligible) {\n        const wasNew = await grantBadgeIfNew(userId, check.type);\n        if (wasNew) granted.push(check.type);\n      }\n    }\n\n    if (granted.length > 0) {\n      console.log(`[useBadges] Selos concedidos para ${userId}:`, granted);\n    }\n  } catch (err) {\n    console.error('[useBadges] Erro no motor de badges:', err);\n  }\n\n  return { granted };\n}\n\n// ── Utilitarios de semana ISO ──\n\nfunction getISOWeek(date: Date): number {\n  const d = new Date(date.getTime());\n  d.setHours(0, 0, 0, 0);\n  d.setDate(d.getDate() + 3 - ((d.getDay() + 6) % 7));\n  const week1 = new Date(d.getFullYear(), 0, 4);\n  return 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + ((week1.getDay() + 6) % 7)) / 7);\n}\n\nfunction areConsecutiveWeeks(newer: string, older: string): boolean {\n  // formato: \"2026-W09\", \"2026-W08\"\n  const [yN, wN] = newer.split('-W').map(Number);\n  const [yO, wO] = older.split('-W').map(Number);\n  if (yN === yO) return wN - wO === 1;\n  if (yN - yO === 1 && wO >= 52 && wN === 1) return true;\n  return false;\n}"
}