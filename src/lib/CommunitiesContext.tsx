{
  "lote": 0,
  "status": "pending",
  "file_path": "src/lib/CommunitiesContext.tsx",
  "created_at": "2026-02-27T05:35:55.798Z",
  "file_content": "import { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport type { ReactNode } from 'react';\nimport { supabase } from './supabase';\nimport { TIMEOUTS } from './supabase';\nimport type { Community } from './supabase';\nimport { COMMUNITIES_CONFIG, COMMUNITY_BY_NAME, FALLBACK_ICON } from './communitiesConfig';\nimport type { CommunityConfig } from './communitiesConfig';\n\n// Mapeamento de nomes antigos do banco → nomes atuais do config\nconst NAME_ALIASES: Record<string, string> = {\n  'Zona de Intensidade': 'Mentes em Tensão',\n};\n\nexport interface CommunityWithMeta extends Community {\n  config: CommunityConfig;\n  postCount: number;\n}\n\ninterface CommunitiesContextValue {\n  communities: CommunityWithMeta[];\n  isLoading: boolean;\n  refreshCommunities: () => Promise<void>;\n  getCommunityById: (id: string) => CommunityWithMeta | undefined;\n  getCommunityByName: (name: string) => CommunityWithMeta | undefined;\n}\n\nconst CommunitiesContext = createContext<CommunitiesContextValue | null>(null);\n\nexport function CommunitiesProvider({ children }: { children: ReactNode }) {\n  const [communities, setCommunities] = useState<CommunityWithMeta[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  const loadCommunities = useCallback(async () => {\n    try {\n      setIsLoading(true);\n\n      // Timeout de 20s para cobrir cold start\n      const timeoutPromise = new Promise<never>((_, reject) =>\n        setTimeout(() => reject(new Error('Timeout communities')), TIMEOUTS.SAFETY_NET)\n      );\n\n      const queryPromise = supabase\n        .from('communities')\n        .select('*')\n        .order('name');\n\n      const { data: dbCommunities, error } = await Promise.race([queryPromise, timeoutPromise]) as any;\n\n      if (error) {\n        console.error('Erro ao buscar comunidades:', error);\n        const fallback = COMMUNITIES_CONFIG.map((config, i) => ({\n          id: `local-${i}`,\n          name: config.name,\n          description: config.description,\n          is_public: true,\n          creator: null,\n          created_at: new Date().toISOString(),\n          owner_id: null,\n          manifesto_text: '',\n          needs_moderator: true,\n          ritual_enabled: false,\n          is_featured: false,\n          max_members: 0,\n          requires_approval: false,\n          config,\n          postCount: 0\n        }));\n        setCommunities(fallback);\n        return;\n      }\n\n      // Contagem otimizada: apenas conta por community_id usando head:true + count\n      // Não puxa todos os posts — só a contagem\n      let countMap: Record<string, number> = {};\n      if (dbCommunities && dbCommunities.length > 0) {\n        try {\n          // Uma query de count por comunidade — mais leve que puxar todos os posts\n          const countPromises = dbCommunities.map(async (c: Community) => {\n            const { count } = await supabase\n              .from('posts')\n              .select('*', { count: 'exact', head: true })\n              .eq('community', c.id);\n            return { id: c.id, count: count || 0 };\n          });\n          // Limite de 15s para contagem — se não conseguir, segue com 0\n          const counts = await Promise.race([\n            Promise.all(countPromises),\n            new Promise<{ id: string; count: number }[]>((resolve) =>\n              setTimeout(() => resolve([]), 15000)\n            ),\n          ]);\n          counts.forEach((c) => { countMap[c.id] = c.count; });\n        } catch {\n          // Contagem falhou — seguir com count = 0\n        }\n      }\n\n      const merged: CommunityWithMeta[] = [];\n\n      if (dbCommunities && dbCommunities.length > 0) {\n        dbCommunities.forEach((dbComm: Community) => {\n          const resolvedName = NAME_ALIASES[dbComm.name] || dbComm.name;\n          const config = COMMUNITY_BY_NAME[resolvedName] || COMMUNITY_BY_NAME[dbComm.name] || {\n            name: dbComm.name,\n            description: dbComm.description,\n            icon: FALLBACK_ICON,\n            color: '#81D8D0',\n            category: 'core' as const,\n            status: 'awaiting_founder' as const,\n            moderatedByMila: false,\n          };\n          merged.push({\n            ...dbComm,\n            name: resolvedName,\n            config,\n            postCount: countMap[dbComm.id] || 0\n          });\n        });\n\n        const dbNames = new Set(dbCommunities.map((c: Community) => c.name));\n        const dbResolvedNames = new Set(dbCommunities.map((c: Community) => NAME_ALIASES[c.name] || c.name));\n        COMMUNITIES_CONFIG.forEach((config, i) => {\n          if (!dbNames.has(config.name) && !dbResolvedNames.has(config.name)) {\n            merged.push({\n              id: `pending-${i}`,\n              name: config.name,\n              description: config.description,\n              is_public: true,\n              creator: null,\n              created_at: new Date().toISOString(),\n              owner_id: null,\n              manifesto_text: '',\n              needs_moderator: true,\n              ritual_enabled: false,\n              is_featured: false,\n              max_members: 0,\n              requires_approval: false,\n              config,\n              postCount: 0\n            });\n          }\n        });\n      } else {\n        COMMUNITIES_CONFIG.forEach((config, i) => {\n          merged.push({\n            id: `pending-${i}`,\n            name: config.name,\n            description: config.description,\n            is_public: true,\n            creator: null,\n            created_at: new Date().toISOString(),\n            owner_id: null,\n            manifesto_text: '',\n            needs_moderator: true,\n            ritual_enabled: false,\n            is_featured: false,\n            max_members: 0,\n            requires_approval: false,\n            config,\n            postCount: 0\n          });\n        });\n      }\n\n      setCommunities(merged);\n    } catch (err) {\n      console.error('Erro ao carregar comunidades:', err);\n      const fallback = COMMUNITIES_CONFIG.map((config, i) => ({\n        id: `local-${i}`,\n        name: config.name,\n        description: config.description,\n        is_public: true,\n        creator: null,\n        created_at: new Date().toISOString(),\n        owner_id: null,\n        manifesto_text: '',\n        needs_moderator: true,\n        ritual_enabled: false,\n        is_featured: false,\n        max_members: 0,\n        requires_approval: false,\n        config,\n        postCount: 0\n      }));\n      setCommunities(fallback);\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadCommunities();\n  }, [loadCommunities]);\n\n  const getCommunityById = useCallback((id: string) => {\n    return communities.find(c => c.id === id);\n  }, [communities]);\n\n  const getCommunityByName = useCallback((name: string) => {\n    return communities.find(c => c.name === name);\n  }, [communities]);\n\n  return (\n    <CommunitiesContext.Provider value={{\n      communities,\n      isLoading,\n      refreshCommunities: loadCommunities,\n      getCommunityById,\n      getCommunityByName\n    }}>\n      {children}\n    </CommunitiesContext.Provider>\n  );\n}\n\n// Fallback seguro para HMR / contexto não disponível\nconst FALLBACK_COMMUNITIES_CONTEXT: CommunitiesContextValue = {\n  communities: [],\n  isLoading: true,\n  refreshCommunities: async () => {},\n  getCommunityById: () => undefined,\n  getCommunityByName: () => undefined,\n};\n\nexport function useCommunitiesContext(): CommunitiesContextValue {\n  const ctx = useContext(CommunitiesContext);\n  if (!ctx) {\n    console.warn('[CommunitiesContext] Contexto não encontrado — usando fallback (isLoading: true)');\n    return FALLBACK_COMMUNITIES_CONTEXT;\n  }\n  return ctx;\n}"
}